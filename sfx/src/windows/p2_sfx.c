/* p2_sfx.c - Self extraction program for P2 installer */

/*************************************************************************
*  Copyright (c) 2014 Mentor Graphics and others.
*  All rights reserved. This program and the accompanying materials
*  are made available under the terms of the Eclipse Public License v1.0
*  which accompanies this distribution, and is available at
*  http://www.eclipse.org/legal/epl-v10.html
*
*  Contributors:
*     Mentor Graphics - initial API and implementation
**************************************************************************/

/*
 * Extracts the binary blobs produced by the code generated by
 * core_build_windows_p2_sfx.sh. The data structure is defined
 * in p2_sfx.h
 *
 * All memory allocations by this program are intentionally not
 * freed until the process exits, due to the fact this is a
 * transient program that only runs to start the installer
 * 
 * There is currently no disk size checking to insure there is 
 * sufficient disk space to perform the extraction.
 *
 * Splash screen must be a 24 bit color BMP. Other color depths
 * are not currently supported
 */

#define _WIN32_WINNT 0x0501

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "p2_sfx.h"
#include <windows.h>
#include <wincon.h>
#include <getopt.h>
#include <unistd.h>
#include <sys/stat.h>
#include <io.h>
#include <fcntl.h>
#include <userenv.h>
#include <sys/time.h>
#include <dirent.h>

#define BMP_IMAGE_DATA_OFFSET 10
#define BMP_IMAGE_WIDTH_OFFSET 18
#define BMP_IMAGE_HEIGHT_OFFSET 22
#define STACK_SIZE 524288
#define RANDOM_STRING_LEN 6
#define TIMESTAMP_LEN 30
#define DIRSEPSTR "\\"
#define INSTALL_ONCE " -install.once "
#define INSTALL_LOG " -install.data="
#define DASH_DATA " -data "
#define LOGS_DIR "logs"
#define VM_ARGS " -vmargs -XX:ErrorFile="
#define VM_ARG_FILE "/jre_error.log"
#define P2_SFX_HIDE_WIN (WM_USER + 1)

/* The bundles[] array and P2_SFX_NUM_BUNDLES variables are defined in the
   generated c file */
extern P2_SFX_FILE_BUNDLE bundles[];
extern int P2_SFX_NUM_BUNDLES;
extern unsigned char splash_bmp[];

/* globals */
static char *g_user_path = NULL;
static char *g_env_var_path = NULL;
static char *g_args = NULL;
static int g_bitmap_width;
static int g_bitmap_height;
static unsigned char * g_image_buffer;
static PBITMAPINFO g_pbmi;
static int g_console_install = FALSE;
static int g_nosplash = FALSE;
static FILE * g_logFile;

/* Fixed size strings */
static char temp_dir_path[MAX_PATH];
static char home_dir_path[MAX_PATH];
static char base_log_dir[MAX_PATH + 
                         sizeof(DIRSEPSTR) + 
                         sizeof(LOG_DIRECTORY) + 1];
static char timestamp_log_dir[sizeof(base_log_dir) +
                              2 * sizeof(DIRSEPSTR) + 
                              sizeof(LOGS_DIR) +
                              TIMESTAMP_LEN + 1];
static char sfx_log_file[sizeof(timestamp_log_dir) +
                         sizeof(DIRSEPSTR) + 
                         sizeof(LOG_FILE) + 1];
static char work_dir_basename[] = BASE_PATH;
static char random_chars[] =
        "abcdefghijklmnopqrstuvwxyz"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "0123456789";
static char helpString[] = "-? | --help | -help | -h\t\tShow this help text\n-location=[path]\t\tUse the specified install location.\n-console\t\t\tPerform a console installation\n-silent\t\t\tPerform a silent installation using defaults.\n-nosplash\t\t\tDo not display splash screen.\n-x [path]\t\t\tExtract installer to [path] but do not start installer.";

static char msg_box_string[5 * sizeof(timestamp_log_dir)];
static char timestamp[TIMESTAMP_LEN + 1];

/******************************************************************************
 * log_message - Writes a message to the log if logging is enabled.
 *
 * @param format Message format
 * @param ... Variable arguments
 * @return None
******************************************************************************/
static void
log_message (const char *format, ...)
{
    va_list ap;

    if (g_logFile == NULL)
        return;
    
    va_start (ap, format);
    vfprintf (g_logFile, format, ap);
    fflush(g_logFile);
    va_end (ap);
}

/******************************************************************************
* allocate_string_buffer
*
* @param size: Size of the buffer not including termination character. The 
* value passed in size is the same value returned by strlen.
*
* @return pointer to the allocated buffer or NULL if the buffer allocation 
* fails.
******************************************************************************/
static char * 
allocate_string_buffer (int size)
{
    char *pch;

    pch = (char *)calloc(1, size + 1);

    if (pch == NULL)
    {
        log_message("Error: Couldn't allocate memory\n");
    }
    return(pch);
}

/******************************************************************************
 * Deletes a directory and all child files and directories.
 * Does not move the directory to the recycle bin or trash.
 *
 * @param directory Full path to the directory
 * @param emptyOnly 1 to only delete directories that are empty
 * @return 0 on success
 ******************************************************************************/
static int
delete_directory (const char *directory, int emptyOnly)
{
    int result = 0;
    struct dirent *entry;
#ifdef _WIN32
    SHFILEOPSTRUCT fileop;
    char *szDirectory;
    int len;
#endif
    DIR *dir;

    if (directory == NULL)
    {
        log_message ("No directory provided");
        return (-1);
    }

    dir = opendir (directory);
    if (dir == NULL)
    {
        log_message ("Failed to open: %s - %s", directory, strerror (errno));
        return(-1);
    }

    while ((entry = readdir (dir)))
    {
        struct stat s;
        char *child;

        /* Skip special entries.  */
        if (strcmp (entry->d_name, ".") == 0)
          continue;
        if (strcmp (entry->d_name, "..") == 0)
          continue;

        child = allocate_string_buffer(strlen(directory) + strlen(entry->d_name) + 1);
        strcpy(child, directory);
        strcat(child, DIRSEPSTR);
        strcat(child, entry->d_name);
        log_message ("child = %s\n", child);
#ifdef _WIN32
        if (stat (child, &s) != 0)
#else
      /* Use lstat on Linux so symbolic links are not followed */
        if (lstat (child, &s) != 0)
#endif
        {
            free (child);
            continue;
        }

      /* Directory */
        if (S_ISDIR (s.st_mode))
        {
            if (delete_directory (child, emptyOnly) != 0)
            {
                result = -1;
                break;
            }
        }
      /* File */
        else
        {
            if (emptyOnly)
            {
                log_message ("Directory not empty: %s", directory);
                result = -1;
                break;
            }
            if (unlink (child) != 0)
            {
                log_message ("Failed to delete file: %s", child);
                result = -1;
                break;
            }
        }

        free (child);
    }

    closedir (dir);
    if (result == 0)
    {
#ifdef _WIN32
        /* SHFileOperation requires double null terminated string */
        len = strlen (directory) + 2;
        szDirectory = (char*)malloc (len);
        memset (szDirectory, 0, len);
        strcpy (szDirectory, directory);

        fileop.hwnd = NULL; /* No window */
        fileop.wFunc = FO_DELETE; /* Delete operation */
        fileop.pFrom = szDirectory; /* Full path to directory */
        fileop.pTo = NULL; /* No destination */
        fileop.fFlags = FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_SILENT; /* Silent operation */
        fileop.fAnyOperationsAborted = FALSE; /* No aborts */
        fileop.lpszProgressTitle = NULL; /* No progress UI title */
        fileop.hNameMappings = NULL; /* No mappings */

        result = SHFileOperation (&fileop);
        free (szDirectory);
#else
        result = rmdir (directory);
#endif
    }
    return result;
}

/******************************************************************************
 * Deletes a set of directories.
 *
 * @param directories Comma separated full paths of directories to delete
 * @param emptyOnly 1 to only delete directory if it is empty
 * @return 0 on success
******************************************************************************/
int
delete_directories (char *directories, int emptyOnly)
{
    int result = 0;
    char *argument = strtok (directories, ",");
    while (argument != NULL)
    {
        result = delete_directory (argument, emptyOnly);
        if (result != 0)
        {
            return -1;
        }
        argument = strtok (NULL, ",");
    }

    return result;
}

/******************************************************************************
 * file_exists - Test whether a file or directory exists.
 *
 * Note this function is copied from instmon/src/main.c
 *
 * @param filename: Full path to the file or directory
 * @return 0 if file does not exists
******************************************************************************/
static int
file_exists (const char *filename)
{
    return (GetFileAttributes (filename) != INVALID_FILE_ATTRIBUTES);
}

/******************************************************************************
 * make_path - Makes a path by creating all required directories.
 *
 * Note this function is copied from instmon/src/main.c
 *
 * @param directory Full path to the directory
 * @param mode Permissions (not used on Windows)
 * @return 0 on success
 ******************************************************************************/
static int
make_path (const char *directory, mode_t mode)
{
    int result = 0;
    char *path;
    char *start;
    char *sp;

    path = strdup (directory);
    if (path == NULL)
    {
      log_message ("Error: Out of memory");
      return (-1);
    }

    start = path;

    while ((sp = strchr (start, DIRSEPSTR[0])) != 0)
    {
        char old = *sp;
        *sp = '\0';
        if ((strlen (path) != 0) && !file_exists (path))
        {
            if (mkdir (path) != 0)
            {
                log_message ("Error: Failed to create directory: %s - %s", path, strerror (errno));
                result = -1;
                break;
            }
        }
        *sp = old;
        start = sp + 1;
    }
    if (!file_exists (directory))
      if (mkdir (path) != 0)
      {
          log_message ("Error: Failed to create directory: %s - %s", path, strerror (errno));
          result = -1;
      }

    free (path);
    return result;
}

/******************************************************************************
* strcpycat - copy and cat two strings
*
* @param string1: Pointer to the first string to be copied into buffer
* @param string2: Pointer to the second string to be cat'd onto the end
* @param buffer: Pointer to the buffer to be copied into. Must be large 
*                enough to contain both string1 and string2
******************************************************************************/
static void 
strcpycat(char *string1, char *string2, char *buffer)
{
    if (string1 == NULL || string2 == NULL || buffer == NULL)
        return;

    strcpy(buffer, string1);
    strcat(buffer, string2);
}

/******************************************************************************
* write_file_desc
*
* @param file_desc: Pointer to the file descriptor that needs to be written as 
*                   a file.
* @param path: Location where the file should be written
*
* @return zero on success, otherwise error
******************************************************************************/
static int 
write_file_desc (P2_SFX_FILE_DESC *file_desc, char *path)
{
    FILE *fout;
    char *buffer;
    int num_bytes_to_write;
    int path_size, file_name_size;
   
    if (file_desc == NULL || path == NULL)
    {
        log_message("Error: Invalid file descriptor\n");
        return -1;
    }

    path_size = strlen(path);
    file_name_size = strlen(file_desc->file_name);

    if (path_size == 0 || file_name_size == 0)
    {
        log_message("Error: Invalid path or filename\n");
        return -1;
    }

    buffer = allocate_string_buffer(path_size + file_name_size);    

    if (buffer == NULL)
    {
        return -1;
    }

    strcpycat(path, file_desc->file_name, buffer);

    log_message("Extracting %s\n", buffer);

    fout = fopen(buffer, "wb+");

    if(fout == NULL || ferror(fout))
    {
        log_message("Error opening %s", buffer);
        return -1;
    }

    num_bytes_to_write = file_desc->file_end_symbol - file_desc->file_start_symbol;
    log_message("Number of bytes: %d\n", num_bytes_to_write);

    fwrite((void *)file_desc->file_start_symbol, 
            num_bytes_to_write, 
            1,
            fout);

    if(ferror(fout))
    {
        log_message("Error restoring %s", buffer);
        log_message("Possibly out of disk space");

        return -1;
    }

    fclose(fout);
    free(buffer);

    return 0;
}

/******************************************************************************
* compare_chars
*
* @param ptr1:
* @param ptr2:
* @param length:
*
* @return 0 if strings are identical, -1 otherwise
******************************************************************************/
static int
compare_chars (char * ptr1, char * ptr2, int length)
{
    int i;

    for (i = 0; i < length; i++)
    {
        if (*ptr1++ != *ptr2++)
            return -1;
    }

    return 0;
}

/******************************************************************************
* replace_sub_string
*
* @param orig_string: Pointer to string containing the substring(s) to be 
*                     replaced.
* @param old_sub_string: substring in orig_string to replace
* @param new_substring: substring that will replace oldSubString in orig_string
*
* All pointers must be valid and non-NULL. Also, the string length of 
* old_substring must be greater than zero.
*
* @return pointer to a new string that replaced all of the occurances of 
* old_substring with new_substring. Note that the memory must be freed by the
* calling function.
******************************************************************************/
static char *
replace_sub_string (char *orig_string,
                    char *old_substring,
                    char *new_substring)
{
    int i;
    int num_replacements = 0;
    int memsize;
    int new_substr_length;
    int old_substr_length;
    char *new_string;
    char *tmp;

    new_substr_length = strlen(new_substring);
    old_substr_length = strlen(old_substring);

    /*
     * Calculate the amount of memory that needs to be allocated for the
     * new string.
     */

    if (new_substr_length != old_substr_length)
    {
        i = 0;
        tmp = orig_string;
        while(*tmp)
        {
            if (compare_chars(tmp, old_substring, old_substr_length) != 0)
            {
                i++;
                tmp++;
            }
            else
            {
                num_replacements++;
                i += old_substr_length;
                tmp += old_substr_length;
            }
        }
    }
    else
    {
        i = strlen(orig_string);
    }

    memsize = i + num_replacements * abs(new_substr_length - old_substr_length);
    new_string = allocate_string_buffer(memsize);
    if (new_string == NULL)
        return NULL;

    /*
     * Create contents of the new string
     */
    tmp = new_string;
    while (*orig_string)
    {
        /*
         * If we haven't found a sub string that matches, then just copy bytes
         * from orig string into new string
         */
        if (compare_chars(orig_string, old_substring, old_substr_length) != 0)
        {
            *tmp = *orig_string;
            tmp++;
            orig_string++;
        }
        else
        {
            char * tmp2 = new_substring;

            for (i = 0; i < new_substr_length; i++)
            {
                *tmp = *tmp2;
                tmp++;
                tmp2++;
            }
            orig_string += old_substr_length;
        }
    }
    *tmp = '\0';

    return new_string;
}

/******************************************************************************
* generate_random_string - Generate a random string containing num_chars number
*                          of characters. This function requires the buffer
*                          to contain sufficient space including space for the 
*                          trailing null character.
*
* @param buffer: pointer to the string 
* @param index: index where to start inserting characters.
* @param num_chars:  number of characters to insert.
*
******************************************************************************/
static void 
generate_random_string  (char *buffer, int index, int num_chars)
{
    int i;

    /* Append the desired number of random characters to the end of the buffer*/
    for (i = index; i < (num_chars + index); i++) 
    {
        int random_index = rand() % (sizeof(random_chars) - 1);

        buffer[i] = random_chars[random_index];
    }

    /* Null terminate the string */
    buffer[i] = 0;
}

/******************************************************************************
* start_process - Start a process
*
* @param command: command to spawn. Will wait until it finishes
*
* @return zero on success, otherwise error
******************************************************************************/
static int 
start_process(char * command)
{
    STARTUPINFO startup_info;
    PROCESS_INFORMATION process_info;
    BOOL return_value;

    memset(&startup_info, 0, sizeof(startup_info));
    startup_info.cb = sizeof(startup_info);

    memset(&process_info, 0, sizeof(process_info));

    /* Create new process */
    return_value = CreateProcess(NULL, command, NULL, NULL, FALSE, CREATE_NO_WINDOW,
                            NULL, NULL, &startup_info, &process_info);

    if(return_value)
    {
        /* Wait for process to exit */
        WaitForSingleObject(process_info.hProcess, INFINITE);
        CloseHandle(process_info.hProcess);
        CloseHandle(process_info.hThread);
        return (0);
    }
    else
    {
        char *errorString;

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      NULL,
                      GetLastError(),
                      0,
                      errorString,
                      64,
                      NULL);
        log_message("Error: CreateProcess returned an error: %s\n", errorString);
        return (-1);
    }
}

/******************************************************************************
* draw_bitmap: Display the bitmap
*
* @param hdc: Current draw context
*
******************************************************************************/
static void 
draw_bitmap(HDC hdc, RECT *pRect)
{
    SetDIBitsToDevice(hdc,
                      pRect->left, /* XDest */
                      pRect->top,  /* YDest */
                      pRect->right - pRect->left, /* dwWidth */
                      pRect->bottom - pRect->top + 1, /* dwHeight */
                      pRect->left, /* XSrc */
                      pRect->top,  /* YSrc */
                      pRect->top,  /* uStartScan */
                      pRect->bottom - pRect->top + 1, /* cScanLines */
                      g_image_buffer, /* lpvBits */
                      g_pbmi, /* BitmapInfo */
                      DIB_RGB_COLORS);
}

/******************************************************************************
* splash_wnd_proc: Splash bitmap window procedure
*
* @param hwnd: handle to window 
* @param msg: message to be processed
* @param wParam: parameter associated with message
* @param lParam: parameter associated with message
*
******************************************************************************/
static LRESULT CALLBACK 
splash_wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HBITMAP hbitmap;

    switch(msg)
    {
        case WM_CREATE:
            g_pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                                    sizeof(BITMAPINFOHEADER)); 
            /* Only 24 bit images supported */
            g_pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
            g_pbmi->bmiHeader.biWidth = g_bitmap_width; 
            g_pbmi->bmiHeader.biHeight = g_bitmap_height; 
            g_pbmi->bmiHeader.biPlanes = 1; 
            g_pbmi->bmiHeader.biBitCount = 24;
            g_pbmi->bmiHeader.biCompression = BI_RGB; 
            g_pbmi->bmiHeader.biSizeImage = (g_bitmap_width * g_bitmap_height *4);
            g_pbmi->bmiHeader.biClrImportant = 0;
        break;
        case WM_CLOSE:
            DestroyWindow(hwnd);
            PostQuitMessage(0);
        break;
        case WM_DESTROY:
            DestroyWindow(hwnd);
            PostQuitMessage(0);
        break;
        case WM_PAINT:
        {
            PAINTSTRUCT paint_struct;
            HDC hdc = BeginPaint(hwnd, &paint_struct);
            RECT rect = paint_struct.rcPaint;

            draw_bitmap(hdc, &rect);

            EndPaint(hwnd, &paint_struct);
        }
        break;
        case P2_SFX_HIDE_WIN:
            ShowWindow(hwnd, SW_HIDE);
        break;
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

/******************************************************************************
* extract_files: extract and restore files from binary. 
*
* @param hwnd: handle to window 
*
******************************************************************************/
static int 
extract_files(HWND hwnd)
{
    char *unix_style_work_dir_path, *command = NULL;
    char *work_dir_path;
    int command_length = 0;
    char *pch1, *pch2, *pch3;
    int i, j;

    log_message("Base extraction path: %s\n", temp_dir_path);

    /* Create the path to the work directory */
    if (g_user_path == NULL)
    {
        work_dir_path = allocate_string_buffer(strlen(temp_dir_path) + strlen(work_dir_basename) + RANDOM_STRING_LEN + strlen(DIRSEPSTR));
       
        if (work_dir_path == NULL)
        {
            fclose(g_logFile);
            if (g_console_install == FALSE || g_nosplash == FALSE)
            {
                sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
                MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                SendMessage(hwnd, WM_DESTROY, 0, 0);
            }
            exit(20);
        }

        if (g_env_var_path == NULL)
        {
            strcpycat(temp_dir_path, work_dir_basename, work_dir_path);
            srand(time(NULL));
            generate_random_string(work_dir_path, strlen(work_dir_path), RANDOM_STRING_LEN);
        }
        else
        {
            strcpy(work_dir_path, temp_dir_path);
        }
        strcat(work_dir_path, DIRSEPSTR);
    }
    else
    {
       log_message("User path: %s\n", g_user_path);

        if (g_user_path[strlen(g_user_path) - 1] != '\\')
        {
            work_dir_path = allocate_string_buffer(strlen(g_user_path) + strlen(DIRSEPSTR));
            if (work_dir_path == NULL)
            {
                fclose(g_logFile);
                if (g_console_install == FALSE || g_nosplash == FALSE)
                {
                    sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
                    MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                    SendMessage(hwnd, WM_DESTROY, 0, 0);
                }
                exit(21);
            }
            strcpycat(g_user_path, DIRSEPSTR, work_dir_path);
        }
        else
        {
            work_dir_path = g_user_path;
        }
    }

    log_message("Extraction path: %s\n", work_dir_path);

    /* Create the work directory */
    if (!file_exists (work_dir_path))
        if (make_path (work_dir_path, 0777) != 0)
        {
            log_message("Could not create directory: %s\n", work_dir_path);
            fclose(g_logFile);
            if (g_console_install == FALSE || g_nosplash == FALSE)
            {
                sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to create directory\n\n", "See the log file at:\n\n", sfx_log_file);
                MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                SendMessage(hwnd, WM_DESTROY, 0, 0);
            }
        exit(22);
        }

    /* Create unix style work dir path */
    unix_style_work_dir_path = replace_sub_string(work_dir_path, DIRSEPSTR, "/");
    if (unix_style_work_dir_path == NULL)
    {
        log_message("Could not allocate memory for directory path\n");
        fclose(g_logFile);
        if (g_console_install == FALSE || g_nosplash == FALSE)
        {
            sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
            MessageBox(hwnd, msg_box_string, NULL, MB_OK);
            SendMessage(hwnd, WM_DESTROY, 0, 0);
        }
        exit(23);
    }

    log_message("Extracting bundles ...\n");

    /* Process bundles */
    for (i = 0; i < P2_SFX_NUM_BUNDLES; i++)
    {
        char *installer_dir_path;

        installer_dir_path = allocate_string_buffer(strlen(work_dir_path) + strlen(bundles[i].path));
        if (installer_dir_path == NULL)
        {
            fclose(g_logFile);
            if (g_console_install == FALSE || g_nosplash == FALSE)
            {
                sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
                MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                SendMessage(hwnd, WM_DESTROY, 0, 0);
            }
            exit(24);
        }

        /* Create path to file */
        strcpycat(work_dir_path, bundles[i].path, installer_dir_path);
        for (j = 0; j < bundles[i].num_file_descs; j++)
        {
            P2_SFX_FILE_DESC *file_desc = &(bundles[i].files[j]);

            if (write_file_desc(file_desc, installer_dir_path))
            {
                fclose(g_logFile);
                if (g_console_install == FALSE || g_nosplash == FALSE)
                {
                    sprintf(msg_box_string, "%s%s%s", "Error extracting files\nPossibly check available disk space.\n\n", "See the log file at:\n\n", sfx_log_file);
                    MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                    SendMessage(hwnd, WM_DESTROY, 0, 0);
                }
                exit(25);
            }
        }
        free(installer_dir_path);

        /* Process commands */
        for (j = 0; j < bundles[i].num_commands; j++)
        {
            char *setupexe;

            setupexe = NULL;

            /* Check to see if command contains setup */
            pch3 = strstr(bundles[i].commands[j], SETUP);

            if (pch3 != NULL)
            {
                if (g_console_install == FALSE)
                {          
                    setupexe = replace_sub_string(bundles[i].commands[j], SETUP, GUI_SETUP_COMMAND);
                }
                else
                {
                    setupexe = replace_sub_string(bundles[i].commands[j], SETUP, CONSOLE_SETUP_COMMAND);
                }
            }

            /* If the command contains setup.exe and there is no user path 
               or if it is any other command that doesn't contain setup */
            if ((setupexe != NULL && g_user_path == NULL) ||
                 setupexe == NULL)
            {
                char * tmp;
                int string_length;

                /* Substitute windows style path */
                if (setupexe == NULL)
                {
                    pch1 = replace_sub_string(bundles[i].commands[j], WINDOWS_BASE_PATH, work_dir_path);
                }
                else
                {
                    pch1 = replace_sub_string(setupexe, WINDOWS_BASE_PATH, work_dir_path);
                }

                if (pch1 == NULL)
                {
                    log_message("Error: Failed to allocate memory for windows path string\n");
                    fclose(g_logFile);
                    if (g_console_install == FALSE || g_nosplash == FALSE)
                    {
                        sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
                        MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                        SendMessage(hwnd, WM_DESTROY, 0, 0);
                    }
                    exit(26);
                }

                /* Substitute unix style path */
                pch2 = replace_sub_string(pch1, UNIX_BASE_PATH, unix_style_work_dir_path);
                free(pch1);

                if (pch2 == NULL)
                {
                    log_message("Error: Failed to allocate memory for unix path string\n");
                    fclose(g_logFile);
                    if (g_console_install == FALSE || g_nosplash == FALSE)
                    {
                        sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
                        MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                        SendMessage(hwnd, WM_DESTROY, 0, 0);
                    }
                    exit(27);
                }

                if (setupexe != NULL)
                {
                    char * install_once = INSTALL_ONCE;
                    char * install_log = INSTALL_LOG;
                    char * dash_data = DASH_DATA;

                    string_length = strlen(pch2) + strlen(install_once) + strlen(dash_data) + (4 * strlen("\"")) + 1;
                    string_length += strlen(install_log) + strlen(base_log_dir) + strlen(timestamp_log_dir) + 1;
                    tmp = allocate_string_buffer(string_length);
                    if (tmp == NULL)
                    {
                        log_message("Error: Failed to allocate memory for implicit arguments\n");
                        fclose(g_logFile);
                        if (g_console_install == FALSE || g_nosplash == FALSE)
                        {
                            sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
                            MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                            SendMessage(hwnd, WM_DESTROY, 0, 0);
                        }
                        exit(28);
                    }
                    strcpy(tmp, pch2);
                    strcat(tmp, install_once);
                    strcat(tmp, install_log);
                    strcat(tmp, "\"");
                    strcat(tmp, base_log_dir);
                    strcat(tmp, "\"");
                    strcat(tmp, dash_data);
                    strcat(tmp, "\"");
                    strcat(tmp, timestamp_log_dir);
                    strcat(tmp, "\"");

                    free(pch2); 
                    pch2 = tmp;
                }

                /* Create command with g_args */
                if (setupexe != NULL && g_args != NULL)
                {
                    string_length = strlen(pch2) + strlen(g_args) + 2;
                    tmp = allocate_string_buffer(string_length);

                    if (tmp == NULL)
                    {
                        log_message("Error: Failed to allocate memory for command with arguments");
                        fclose(g_logFile);
                        if (g_console_install == FALSE || g_nosplash == FALSE)
                        {
                            sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
                            MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                            SendMessage(hwnd, WM_DESTROY, 0, 0);
                        }
                        exit(29);
                    }
                    strcpy(tmp, pch2);
                    strcat(tmp, " ");
                    strcat(tmp, g_args);
                    free(pch2); 
                    pch2 = tmp;
                }

                if (setupexe != NULL)
                {
                    string_length = strlen(pch2) + strlen(VM_ARGS) + 
                                    strlen(VM_ARG_FILE) + strlen(timestamp_log_dir) + 3;
                    tmp = allocate_string_buffer(string_length);

                    if (tmp == NULL)
                    {
                        log_message("Error: Failed to allocate memory for vm args");
                        fclose(g_logFile);
                        if (g_console_install == FALSE || g_nosplash == FALSE)
                        {
                            sprintf(msg_box_string, "%s%s%s", "Error extracting files\nUnable to allocate memory\n\n", "See the log file at:\n\n", sfx_log_file);
                            MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                            SendMessage(hwnd, WM_DESTROY, 0, 0);
                        }
                        exit(29);
                    }

                    strcpy(tmp, pch2);
                    strcat(tmp, VM_ARGS);
                    strcat(tmp, "\"");
                    strcat(tmp, timestamp_log_dir);
                    strcat(tmp, VM_ARG_FILE);
                    strcat(tmp, "\"");
                    free(pch2); 
                    pch2 = tmp;
                }

                /* Execute command */
                log_message("Executing command: %s\n", pch2);

                if (setupexe == NULL)
                {
                    /* All non-setup commands use CreateProcess */
                    if(start_process(pch2))
                    {
                        log_message("Error: Failed to execute %s\n", pch2);
                        fclose(g_logFile);
                        if (g_console_install == FALSE || g_nosplash == FALSE)
                        {
                            sprintf(msg_box_string, "%s%s%s", "Error extracting files\nCommand failure\n\n", "See the log file at:\n\n", sfx_log_file);
                            MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                            SendMessage(hwnd, WM_DESTROY, 0, 0);
                        }
                        exit(30);
                    }
                }
                else
                {
                    /* Split the command into a "command" and "argument" format */
                    char * exestring = allocate_string_buffer(strlen(pch2));
                    char * cmdargs = allocate_string_buffer(strlen(pch2));
                    HINSTANCE return_value;

                    tmp = strstr(pch2, ".exe");
                    tmp += (strlen(".exe") + 1);
                    strncpy(exestring, pch2, strlen(pch2) - strlen(tmp));
                    exestring[strlen(pch2) - strlen(tmp)] = 0;
                    strcpy(cmdargs, tmp);

                    log_message("Installer command = %s\n", exestring);
                    log_message("Installer arguments = %s\n", cmdargs);

                    return_value = ShellExecute(NULL, "open", exestring, cmdargs, NULL, SW_SHOWNORMAL);

                    if ((int)return_value <= 32)
                    {
                        log_message("Error: ShellExecute returned a value of %d\n", (int)return_value);
                        fclose(g_logFile);
                        if (g_console_install == FALSE || g_nosplash == FALSE)
                        {
                            sprintf(msg_box_string, "%s%s%s", "Error extracting files\nCommand failure\n\n", "See the log file at:\n\n", sfx_log_file);
                            MessageBox(hwnd, msg_box_string, NULL, MB_OK);
                            SendMessage(hwnd, WM_DESTROY, 0, 0);
                        }
                        exit(31);
                    }
                    
                }

                free(pch2);
            }
        }
    }

    if (g_console_install == FALSE || g_nosplash == FALSE)
    {
        SendMessage(hwnd, WM_DESTROY, 0, 0);
    } 

    return 0;
}

/******************************************************************************
* extract_files_app: create window
*
* @param hInstance
* @param hPrevInstance
* @param nCmdShow
******************************************************************************/
static int WINAPI 
extract_files_app (HINSTANCE hInstance, 
                   HINSTANCE hPrevInstance, 
                   int nCmdShow)
{
    WNDCLASSEX wc;
    const char szClassName[] = "MentorExtractorWinClass";
    MSG Msg;
    HWND hwnd;
    unsigned int threadID;
    int return_value;

    if (g_console_install == TRUE || g_nosplash == TRUE)
    {
        /* Separate thread not created when a window isn't created */
        return_value = extract_files(NULL);
        fclose(g_logFile);
        log_message("Successfully exiting extraction app\n");
        log_message("------------------------------------\n\n");
        return(return_value);
    }
    else
    {
        //Registering the Window Class
        wc.cbSize        = sizeof(WNDCLASSEX);
        wc.style         = 0;
        wc.lpfnWndProc   = splash_wnd_proc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hInstance;
        wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = szClassName;
        wc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);

        if(!RegisterClassEx(&wc))
        {
            MessageBox(NULL, "Window Registration Failed!", "Error!",
                       MB_ICONEXCLAMATION | MB_OK);
            log_message("Error: Window Registration Failed!");
            fclose(g_logFile);
            return -1;
        }

        /* Get BMP information from bitmap header */
        g_image_buffer = splash_bmp + *((unsigned int *)(splash_bmp + BMP_IMAGE_DATA_OFFSET));
        g_bitmap_width = *((unsigned int *)(splash_bmp + BMP_IMAGE_WIDTH_OFFSET));
        g_bitmap_height = *((unsigned int *)(splash_bmp + BMP_IMAGE_HEIGHT_OFFSET));

        /* Create the Window */
        hwnd = CreateWindowEx(
            0,
            szClassName,
            "P2 Installer extracting files ...",
            WS_POPUP|WS_VISIBLE|WS_SYSMENU, /* WS_VISIBLE, */
            GetSystemMetrics(SM_CXSCREEN)/2-g_bitmap_width/2,
            GetSystemMetrics(SM_CYSCREEN)/2-g_bitmap_height/2,
            g_bitmap_width - 1, g_bitmap_height - 1,
            NULL, NULL, hInstance, NULL);

        if(hwnd == NULL)
        {
            MessageBox(NULL, "P2 Extraction Window Creation Failed!", "Error!",
                       MB_ICONEXCLAMATION | MB_OK);
            log_message("Error: Window Creation Failed!\n");
            fclose(g_logFile);
            return -1;
        }

        ShowWindow(hwnd, nCmdShow);
        return_value = UpdateWindow(hwnd);
        if (return_value == 0)
        {
            log_message("Error: UpdateWindow failed");
            fclose(g_logFile);
            return -1;
        }
    
        /* Create thread to extract files */
        return_value = _beginthreadex(NULL, STACK_SIZE,
                                      (unsigned (__stdcall *)( void * ))extract_files,
                                      (void *)hwnd,
                                      0,
                                      &threadID);

        if (return_value == 0)
        {
            log_message("Error: Unable to start thread. Errno value: %d\n", strerror (errno));
            fclose(g_logFile);
            return -1;
        }
    
        // The Message Loop
        while(GetMessage(&Msg, NULL, 0, 0) > 0)
        {
            TranslateMessage(&Msg);
            DispatchMessage(&Msg);
        }

        log_message("Successfully exiting extraction app\n");
        log_message("------------------------------------\n\n");
        fclose(g_logFile);
        return Msg.wParam;
    }
}

/******************************************************************************
* WinMain: Entry point
*
* @param hInstance
* @param hPrevInstance
* @param lpCmdLine
* @param nCmdShow
* 
* @return 
******************************************************************************/
int WINAPI 
WinMain(HINSTANCE hInstance, 
                  HINSTANCE hPrevInstance,
                  LPSTR lpCmdLine, 
                  int nCmdShow)
{
    int argc = 0;
    char **argv;
    int i;
    char *nosplash_string = "-nosplash ";
    int arg_length = 0;
    char filename[MAX_PATH];
    char time[MAX_PATH];
    SYSTEMTIME sys_time;
    DWORD return_value;

    /* Get command line args */

    if(*lpCmdLine != 0)
    {
        argc = __argc;
        argv = __argv;
    }

    for (i = 1; i < argc; i++)
    {
        if (strstr(argv[i], "-?") != NULL ||
            strstr(argv[i], "-help") != NULL ||
            strstr(argv[i], "--help") != NULL ||
            strstr(argv[i], "-h") != NULL)
        {
            MessageBox(NULL, helpString, "Help", MB_OK);
            exit(0);
        }
    }

    /* Get user home directory */
    return_value = GetEnvironmentVariable("userprofile", home_dir_path, MAX_PATH);

    if (return_value == 0)
    {
        MessageBox(NULL, "Extraction error: could not obtain user directory", NULL, MB_OK);
        exit(1);
    }

    /* Create log file */
    GetSystemTime(&sys_time);
    return_value = GetTimeFormat(MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT), 0, NULL, NULL, time, MAX_PATH);
    if (return_value == 0) 
    {
        MessageBox(NULL, "Extraction error: Invalid timestamp information received from the OS\n", NULL, MB_OK);
        exit(2);
    }

    strcpy(base_log_dir, home_dir_path);
    strcat(base_log_dir, DIRSEPSTR);
    strcat(base_log_dir, LOG_DIRECTORY);

    strcpy(timestamp_log_dir, base_log_dir);

    sprintf(timestamp, "%04d%02d%02d%02d%02d%02d", sys_time.wYear,sys_time.wMonth,sys_time.wDay,sys_time.wHour,sys_time.wMinute,sys_time.wSecond);
    strcat(timestamp_log_dir, DIRSEPSTR);
    strcat(timestamp_log_dir, LOGS_DIR);
    strcat(timestamp_log_dir, DIRSEPSTR);
    strcat(timestamp_log_dir, timestamp);

    if (!file_exists(timestamp_log_dir))
    {
        if (make_path(timestamp_log_dir, 0777) != 0)
        {
            sprintf(msg_box_string, "Extraction error: could not create log directory\n\n%s", timestamp_log_dir);
            MessageBox(NULL, msg_box_string, NULL, MB_OK);
            exit(2);
        }
    }

    strcpy(sfx_log_file, timestamp_log_dir);
    strcat(sfx_log_file, DIRSEPSTR);

    strcat(sfx_log_file, LOG_FILE);
    g_logFile = fopen(sfx_log_file, "a+");

    if(g_logFile == NULL || ferror(g_logFile))
    {
        sprintf(msg_box_string, "Extraction error: could not create log file\n\n%s", sfx_log_file);
        MessageBox(NULL, msg_box_string, NULL, MB_OK);
        exit(3);
    }

    /* Logging is available from this point forward */

    /* Log timestamp */
    log_message("------------------------------------\n");
    log_message("Installation timestamp: %d-%d-%d, %s\n",
                sys_time.wYear, sys_time.wMonth, sys_time.wDay, time);


    log_message("Raw command line: %s\n", lpCmdLine);
    
    return_value = GetModuleFileName(NULL, filename, MAX_PATH);

    if (return_value == 0)
    {
        char *errorString;

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      NULL,
                      GetLastError(),
                      0,
                      errorString,
                      64,
                      NULL);
        log_message("Error getting module information: %s\n", errorString);
        fclose(g_logFile);
        sprintf(msg_box_string, "Extraction error. See the following file\n\n%s", sfx_log_file);
        MessageBox(NULL, msg_box_string, NULL, MB_OK);
        exit(4);
    }

    for (i = 0; i < argc; i++)
    {
        if (strcmp(argv[i], "-x") == 0)
        {
            if (i + 1 < argc)
            {
                g_user_path = argv[i + 1];
            }
            else
            {
                log_message("-x option requires a path to be provided\n");
                log_message("%s -x <path>\n", filename);
                fclose(g_logFile);
                sprintf(msg_box_string, "Extraction error. See the following file\n\n%s", sfx_log_file);
                MessageBox(NULL, msg_box_string, NULL, MB_OK);
                exit(5);
            }
            /* Uncomment this if no splash is desired during -x install */
            /* g_nosplash = TRUE; */
            break;
        }
    }

    /* Check to see if user used -x */
    if (g_user_path != NULL && strlen(g_user_path) <= MAX_PATH)
    {
        strcpy(temp_dir_path, g_user_path);
        if (!file_exists (g_user_path))
            if (make_path (g_user_path, 0777) != 0)
            {
                log_message("Could not create directory: %s\n", g_user_path);
                fclose(g_logFile);
                sprintf(msg_box_string, "Extraction error. See the following file\n\n%s", sfx_log_file);
                MessageBox(NULL, msg_box_string, NULL, MB_OK);
                exit(6);
            }
    }
    else if (g_user_path != NULL)
    {
        /* We only accept paths that are MAX_PATH in length */
        log_message("Error: path provided with -x option is invalid \"%s\"\n", g_user_path);
        log_message("Note: path cannot exceed %d characters\n", MAX_PATH);
        fclose(g_logFile);
        sprintf(msg_box_string, "Extraction error. See the following file\n\n%s", sfx_log_file);
        MessageBox(NULL, msg_box_string, NULL, MB_OK);
        exit(7);
    }
    else
    {
        int ret_val;

        ret_val = GetEnvironmentVariable(TEMP_PATH_ENV, temp_dir_path, MAX_PATH);

        /* Find the directory to the tmp directory */
        if (ret_val == 0 || ret_val > MAX_PATH)
        {
            if (GetTempPath (MAX_PATH, temp_dir_path) == 0)
            {
                log_message("Error: Could not find temporary directory to extract files\n");
                fclose(g_logFile);
                sprintf(msg_box_string, "Extraction error. See the following file\n\n%s", sfx_log_file);
                MessageBox(NULL, msg_box_string, NULL, MB_OK);
                exit(8);
            }
        }
        /* The user supplied a path via environment variable */
        else
        {
            g_env_var_path = temp_dir_path;
            /* temp_dir_path already contains the path; no need to copy it */
            log_message("Temporary path obtained from \"%s\" environment variable: \"%s\"\n", TEMP_PATH_ENV, temp_dir_path);
        }
    }

    /* Check to see if there are arguments to pass to setup; only valid
       if the user didn't specify an installation path (if they 
       specified a path that means we won't be calling setup) */
    if (argc > 0 && g_user_path == NULL)
    {
        short nosplash_set = FALSE;
        short installsilent_set = FALSE;
        short installconsole_set = FALSE;
        short installlocation_set = FALSE;

        /* Allocate memory for argument string */
        for (i = 0; i < argc; i++)
        {
            arg_length += strlen(argv[i]);

            /* Add one more for the space in between args*/
            arg_length++;
        }

        /* Allocate space for an extra -nosplash and extra space if -console is
           used instead of -install.console or -install.silent */
        arg_length += strlen(nosplash_string) + strlen(".console") + strlen(".location");

        g_args = allocate_string_buffer(arg_length);

        if (g_args == NULL)
        {
            log_message("Error: Couldn't allocate memory for arguments: %d\n", arg_length);
            fclose(g_logFile);
            sprintf(msg_box_string, "Extraction error. See the following file\n\n%s", sfx_log_file);
            MessageBox(NULL, msg_box_string, NULL, MB_OK);
            exit(9);
        }

        /* Add the arguments to the g_args string */
        for (i = 1; i < argc; i++)
        {
            log_message("argv[%d] = %s\n", i, argv[i]);

            if (((strstr(argv[i], "-install.silent") != NULL) ||
                  (strstr(argv[i], "-silent") != NULL)) &&
                installsilent_set == FALSE &&
                installconsole_set == FALSE)
            {
                g_console_install = TRUE;
                installsilent_set = TRUE;
                if (nosplash_set == FALSE)
                {
                    nosplash_set = TRUE;
                    strcat(g_args, nosplash_string);
                }
                strcat(g_args, "-install.silent ");
            }
            else if (((strstr(argv[i], "-install.console") != NULL) || 
                      (strstr(argv[i], "-console") != NULL)) &&
                     installconsole_set == FALSE &&
                     installsilent_set == FALSE)
            {
                g_console_install = TRUE;
                installconsole_set = TRUE;
                if (nosplash_set == FALSE)
                {
                    nosplash_set = TRUE;
                    strcat(g_args, nosplash_string);
                }
                strcat(g_args, "-install.console ");
            }
            else if (((strstr(argv[i], "-install.location") != NULL) || 
                      (strstr(argv[i], "-location") != NULL))&&
                     installlocation_set == FALSE)
            {
                char * pch = NULL;

                pch = strtok(argv[i], "=");
                if (pch != NULL)
                {
                    pch = strtok(NULL, "=");
                    if (pch != NULL)
                    {
                        installlocation_set = TRUE;
                        strcat(g_args, "-install.location=");
                        strcat(g_args, pch);
                        strcat(g_args, " ");
                    }
                }
                if (pch == NULL)
                {
                    strcat(g_args, argv[i]);
                    strcat(g_args, " ");
                }
            }
            else if (strstr(argv[i], "-nosplash") != NULL &&
                     nosplash_set == FALSE)
            {
                nosplash_set = TRUE;
                g_nosplash = TRUE;
                strcat(g_args, nosplash_string);
            }
            else
            {
                strcat(g_args, argv[i]);
                strcat(g_args, " ");
            }
        }
        log_message("arguments list: %s\n", g_args);
    }
    
    return (extract_files_app(hInstance, hPrevInstance, nCmdShow));
}

